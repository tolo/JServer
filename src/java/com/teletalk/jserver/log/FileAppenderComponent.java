/*
 * Copyright 2007 the project originators.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 TODO: Make autoFlushEnabled into property
 TODO: Property for encoding
 */
package com.teletalk.jserver.log;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;

import org.apache.log4j.Layout;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.LoggingEvent;

import com.teletalk.jserver.StatusTransitionException;
import com.teletalk.jserver.SubComponent;
import com.teletalk.jserver.property.NumberProperty;
import com.teletalk.jserver.property.Property;
import com.teletalk.jserver.property.StringProperty;

/**
 * A AppenderComponent class for logging to a file. This class is a subclass of PeriodicityAppenderComponent which enables
 * it to change the current logfile with a given periodicity.<br>
 * <br>
 * By default, this class uses {@link com.teletalk.jserver.log.ExtendedPatternLayout} as layout.<br>
 * <br>
 * This class replaces the 1.X class FileLogger.
 * 
 * @see com.teletalk.jserver.log.ExtendedPatternLayout 
 * 
 * @author Tobias Löfstrand
 * 
 * @since 2.0
 */
public class FileAppenderComponent extends PeriodicityAppenderComponent implements FilenameFilter
{
   /** The default suffix of logfiles generated by this FileAppenderComponent.  */
   public final static String logfileSuffix = ".log";
   
   public static final String DEFAULT_LAYOUT_PATTERN = "%d  %-5p  [%c] - %m %S";
   
   private static final long lineBreakLength;
   
   static
   {
      String lineSep = System.getProperty("line.separator");
      if( lineSep == null ) lineBreakLength = 2;
      else lineBreakLength = lineSep.length();
   }
   
   
   /** The PrintWriter used to write logs to file. */
   protected PrintWriter writer;
   
   protected FileDescriptor currentLogFileDescriptor;
   
   /** Property for the interval at which the logfile should be flushed. */
   protected NumberProperty flushInterval;
   
   /** Property for base path of logs generated by this FileAppenderComponent. */
   protected StringProperty logFilePath;
   
   protected StringProperty defaultLayoutPattern;
   
   /** @since 2.1.2 (20060224) */
   protected NumberProperty maxFileSize;
   
   
   /** Time of the last flush of the logfile. */
   protected long lastLogFileFlush;

   
   /** Boolean flag indicating if a flush is needed. */
   protected boolean flushNeeded = false;
   
   /** Boolean flag indicating if automatic flushing is enabled. */
   protected boolean autoFlushEnabled = false;  //
   
   /** Flag indicating if the logger has been enabled and initialized. */
   protected boolean logFileInitialized = false;
   
   
   private String fileHeader = null;
   
   
   private long bytesWritten = 0;
   
      
   /**
    * Constructs a new FileAppenderComponent named "FileAppenderComponent" with default periodicity, logprefix, logsuffix and base path.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * 
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent)
   {
      this(parent, "FileAppender");
   }
   
   /**
    * Constructs a new FileAppenderComponent with default periodicity, logprefix,  logsuffix and base path.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * @param name the name of this FileAppenderComponent.
    * 
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent, String name)
   {
      this(parent, name, null, logfileSuffix);
   }
   
   /**
    * Constructs a new FileAppenderComponent with default periodicity and base path.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * @param name the name of this FileAppenderComponent.
    * @param logFileNamePrefix the filename prefix for logfiles.
    * @param logFileNameSuffix the filename suffix for logfiles.
    * 
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent, String name, String logFileNamePrefix, String logFileNameSuffix)
   {
      this(parent, name, logFileNamePrefix, logFileNameSuffix, "");
   }
   
   /**
    * Constructs a new FileAppenderComponent with default periodicity.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * @param name the name of this FileAppenderComponent.
    * @param logFileNamePrefix the filename prefix for logfiles.
    * @param logFileNameSuffix the filename suffix for logfiles.
    * @param basePath the base path of log file names.
    * 
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent, String name, String logFileNamePrefix, String logFileNameSuffix, String basePath)
   {
      super(parent, name, logFileNamePrefix, logFileNameSuffix);
      
      initLogFileNamePrefixAndSuffix(super.logPrefix.stringValue(), super.logSuffix.stringValue());
      
      lastLogFileFlush = 0;
      
      this.createProperties(basePath);
   }
   
   /**
    * Constructs a new FileAppenderComponent with default base path.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * @param name the name of this FileAppenderComponent.
    * @param logFileNamePrefix the filename prefix for logfiles.
    * @param periodicity the periodicity of this FileAppenderComponent.
    * 
    * @see PeriodicityAppenderComponent#periodicity
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent, String name, String logFileNamePrefix, String logFileNameSuffix, int periodicity)
   {
      this(parent, name, logFileNamePrefix, logFileNameSuffix, "", periodicity);
   }
   
   /**
    * Constructs a new FileAppenderComponent.
    * 
    * @param parent the parent of this FileAppenderComponent.
    * @param name the name of this FileAppenderComponent.
    * @param logFileNamePrefix the filename prefix for logfiles.
    * @param basePath the base path of log file names.
    * @param periodicity the periodicity of this FileAppenderComponent.
    * 
    * @see PeriodicityAppenderComponent#periodicity
    * @see LogManager
    */
   public FileAppenderComponent(SubComponent parent, String name, String logFileNamePrefix, String logFileNameSuffix, String basePath, int periodicity)
   {
      super(parent, name, logFileNamePrefix, logFileNameSuffix, periodicity);
      
      initLogFileNamePrefixAndSuffix(super.logPrefix.stringValue(), super.logSuffix.stringValue());
      
      lastLogFileFlush = 0;
      
      this.createProperties(basePath);
   }
   
   /**
    */
   private void createProperties(String basePath)
   {
      this.flushInterval = new NumberProperty(this, "flushInterval", 5*1000, Property.MODIFIABLE_NO_RESTART);
      this.flushInterval.setDescription("The interval in millisconds between log file flushes.");
      this.addProperty(flushInterval);
      this.logFilePath = new StringProperty(this, "logFilePath", basePath, Property.MODIFIABLE_OWNER_RESTART); 
      this.logFilePath.setDescription("The base path of logfiles generated by this FileAppenderComponent.");
      this.addProperty(logFilePath);
      this.defaultLayoutPattern = new StringProperty(this, "defaultLayoutPattern", DEFAULT_LAYOUT_PATTERN, Property.MODIFIABLE_NO_RESTART); 
      this.defaultLayoutPattern.setDescription("The pattern to be used for the layout (ExtendedPatternLayout by default).");
      this.addProperty(defaultLayoutPattern);
      this.maxFileSize = new NumberProperty(this, "maxFileSize", -1, Property.MODIFIABLE_NO_RESTART);
      this.maxFileSize.setDescription("The maximum size (in MB) of a log file. If the size of the file is larger than this value, a new file will be created. " +
            "If this property is set to 0 or below, the file size may be unlimited.");
      this.addProperty(maxFileSize);
   }
   
   /**
    */
   private void initLogFileNamePrefixAndSuffix(String logFileNamePrefix, String logFileNameSuffix)
   {
      // Replace illegal characters in logFileNamePrefix with _
      logFileNamePrefix = replaceInvalidFileNameChars(logFileNamePrefix);
      super.logPrefix.setForceMode(true);
      super.logPrefix.setNotificationMode(false);
      super.logPrefix.setValue(logFileNamePrefix);
      super.logPrefix.setNotificationMode(true);
      super.logPrefix.setForceMode(false);
      
      // Replace illegal characters in logFileNameSuffix with _
      logFileNameSuffix = replaceInvalidFileNameChars(logFileNameSuffix);
      super.logSuffix.setForceMode(true);
      super.logSuffix.setNotificationMode(false);
      super.logSuffix.setValue(logFileNameSuffix);
      super.logSuffix.setNotificationMode(true);
      super.logSuffix.setForceMode(false);
   }
   
   /**
    * Enables this FileAppenderComponent.
    */
   public synchronized void doInitialize()
   {
      super.doInitialize();
      
      // Attempt to get old property "flush interval"
      super.initFromConfiguredProperty(this.flushInterval, "flush interval", false, true);
      // Attempt to get old property "layout pattern"
      super.initFromConfiguredProperty(this.defaultLayoutPattern, "layout pattern", false, true);
      
      new File(logFilePath.stringValue()).mkdirs();
      
      if( super.getLayout() == null )
      {
         super.setLayout(new ExtendedPatternLayout(this.defaultLayoutPattern.stringValue()));
      }
         
      try
      {
         changeLogFile(true);
      }
      catch(IOException e)
      {
         throw new StatusTransitionException("Error while enabling", e);
      }
      
      logFileInitialized = true;
   }
   
   /**
    * Disables this FileAppenderComponent.
    */
   public synchronized void doShutDown()
   {
      if( writer != null )
      {
         writer.flush();
	      
	      try
	      {
	         Thread.sleep(500);
	      }
	      catch(InterruptedException e){}
	      
	      writer.close();
      }
      
      writer = null;
      
      logFileInitialized = false;
   }
   
   /**
    * Validates a modification of a property's value. 
    *  
    * @param property The property to be validated.
    * 
    * @return boolean value indicating if the property passed (true) validation or not (false).
    */
   public boolean validatePropertyModification(Property property)
   {
      if(property == super.logPrefix)
      {
         String oldLogPrefix = super.logPrefix.stringValue();
         String newLogPrefix = replaceInvalidFileNameChars(oldLogPrefix);
         if(!newLogPrefix.equals(oldLogPrefix))
         {
            super.logPrefix.setForceMode(true);
            super.logPrefix.setNotificationMode(false);
            super.logPrefix.setValue(newLogPrefix);
            super.logPrefix.setNotificationMode(true);
            super.logPrefix.setForceMode(false);
            
            logInfo("Value of property logPrefix changed from '" + oldLogPrefix +  "' to '" + newLogPrefix + "' during validation.");
         }
         return true;
      }
      else if(property == super.logSuffix)
      {
         String oldLogSuffix = super.logSuffix.stringValue();
         String newLogSuffix = replaceInvalidFileNameChars(oldLogSuffix);
         if(!newLogSuffix.equals(oldLogSuffix))
         {
            super.logSuffix.setForceMode(true);
            super.logSuffix.setNotificationMode(false);
            super.logSuffix.setValue(newLogSuffix);
            super.logSuffix.setNotificationMode(true);
            super.logSuffix.setForceMode(false);
            
            logInfo("Value of property logSuffix changed from '" + oldLogSuffix +  "' to '" + newLogSuffix + "' during validation.");
         }
         return true;
      }
      else if(property == logFilePath)
      {
         if( logFilePath.stringValue() == null )
         {
            logFilePath.setForceMode(true);
            logFilePath.setNotificationMode(false);
            logFilePath.setValue("");
            logFilePath.setNotificationMode(true);
            logFilePath.setForceMode(false);
         }
         else if( "".equals(logFilePath.stringValue()) )
         {
            return true;
         }
         else
         {
            File f = new File(logFilePath.stringValue());
            
            if(!f.exists()) new File(logFilePath.stringValue()).mkdirs();
            
            if(f.isDirectory()) 
            {
               logFilePath.setForceMode(true);
               logFilePath.setNotificationMode(false);
               logFilePath.setValue(f.getPath() + File.separator);
               logFilePath.setNotificationMode(true);
               logFilePath.setForceMode(false);
                              
               return true;
            }
         }
         return false;
      }
      else return super.validatePropertyModification(property);
   }
   
   /**
    * Called when a property owned by this AppenderComponent is modified.
    */
   public void propertyModified(Property property)
   {
      super.propertyModified(property);
      
      if( property == this.defaultLayoutPattern )
      {
         Layout layout = super.getLayout();
         if( (layout != null) && (layout instanceof PatternLayout) )
         {
            ((PatternLayout)layout).setConversionPattern(this.defaultLayoutPattern.stringValue());
         }
      }
   }
   
   
   /* ### GETTERS/SETTERS ### */
   
   
   /**
    * Sets the value of the flag indicating if a flush should be performed every time the 
    * {@link #append(LoggingEvent)} method is called.<br>
    * <br>
    * This flag is set to <code>false</code> by default.
    * 
    * @param autoFlushEnabled the new value of the flag.
    */
   public void setAutoFlushMode(boolean autoFlushEnabled)
   {
      this.autoFlushEnabled = autoFlushEnabled;
   }
   
   /**
    * Gets the value of the flag indicating if a flush should be performed every time the 
    * {@link #append(LoggingEvent)} method is called.<br>
    * <br>
    * This flag is set to <code>false</code> by default.
    * 
    * @return the value of the flag.
    */
   public boolean getAutoFlushMode()
   {
      return this.autoFlushEnabled;
   }
   
   /**
    * Gets the file header.
    * 
    * @since 2.1.1 (20051229)
    */
   public String getFileHeader()
   {
      return fileHeader;
   }

   /**
    * Sets the file header.
    * 
    * @since 2.1.1 (20051229)
    */
   public void setFileHeader(String fileHeader)
   {
      this.fileHeader = fileHeader;
   }
   
   /**
    * Gets the layout pattern for the default log4j layout ({@link ExtendedPatternLayout}) used for formatting messages.
    * 
    * @since 2.1.1 (20060112)
    */
   public String getDefaultLayoutPattern()
   {
      return defaultLayoutPattern.stringValue();
   }

   /**
    * Sets the layout pattern for the default log4j layout ({@link ExtendedPatternLayout}) used for formatting messages.
    * 
    * @since 2.1.1 (20060112)
    */
   public void setDefaultLayoutPattern(String defaultLayoutPattern)
   {
      this.defaultLayoutPattern.setValue(defaultLayoutPattern);
   }

   /**
    * Gets the log file flush interval.
    * 
    * @since 2.1.1 (20060112)
    */
   public long getFlushInterval()
   {
      return flushInterval.longValue();
   }

   /**
    * Sets the log file flush interval.
    * 
    * @since 2.1.1 (20060112)
    */
   public void setFlushInterval(long flushInterval)
   {
      this.flushInterval.setValue(flushInterval);
   }

   /**
    * Gets the log file path.
    * 
    * @since 2.1.1 (20060112)
    */
   public String getLogFilePath()
   {
      return logFilePath.stringValue();
   }

   /**
    * Sets the log file path.
    * 
    * @since 2.1.1 (20060112)
    */
   public void setLogFilePath(String logFilePath)
   {
      this.logFilePath.setValue(logFilePath);
   }
   
   /**
    * Sets the maximum log file size in MB. If the size of the file is larger than this value, a new file will be created. 
    * If this property is set to 0 or below, the file size may be unlimited.
    * 
    * @since 2.1.5 (20070417)
    */
   public long getMaxFileSize()
   {
      return maxFileSize.longValue();
   }
   
   /**
    * Gets the maximum log file size in MB. If the size of the file is larger than this value, a new file will be created. 
    * If this property is set to 0 or below, the file size may be unlimited.
    * 
    * @since 2.1.5 (20070417)
    */
   public void setMaxFileSize(long maxFileSize)
   {
      this.maxFileSize.setValue(maxFileSize);
   }
   
   
   /* ### LOGGING RELATED METHODS  ### */
   

   /**
    * Called to record a LoggingEvent to this AppenderComponent.<br>
    * <br>
    * Note: This method is not thread safe.
    * 
    * @param event the LoggingEvent to record.
    * 
    * @throws Exception if an error occurred while attempting to record the event.
    */
   public void append(final LoggingEvent event) throws Exception
   {
      if( !logFileInitialized ) return;
      
      this.checkNextLogFileChange();
      
      String formattedMessage = super.getLayout().format(event);
      final char[] newStr = formattedMessage.toCharArray();
      int charCount = 0;
      
      // Remove linebreaks from message text
      for(int i=0; i<newStr.length; i++)
      {
         if( (newStr[i] == '\r') || (newStr[i] == '\n') || (newStr[i] == '\t') || (newStr[i] == '\f') )
         {
            // Skip all following linebreaks...
            for(; ((i+1)<newStr.length) && ((newStr[i+1] == '\r') || (newStr[i+1] == '\n') || (newStr[i+1] == '\t') || (newStr[i+1] == '\f')); i++);
            
            // Replace with space, but only if not first character
            if( (charCount > 0) )
            {
               newStr[charCount] = ' ';
               charCount++;
            }
         }
         else
         {
            newStr[charCount] = newStr[i];
            charCount++;
         }
      }
      
      this.writer.println(new String(newStr, 0, charCount));
      
      if(this.autoFlushEnabled)
      {
         writer.flush();
      }
      else
      {
         flushNeeded = true;
      }
      
      // Increase bytesWritten
      this.bytesWritten += charCount + lineBreakLength;
   }
   
   /**
    * Flushes logmessages to log file.
    */
   public void flushBuffers()
   {
      if(flushNeeded && ((System.currentTimeMillis() - lastLogFileFlush) > flushInterval.intValue()))
      {
         this.forceFlush();
      }
   }
   
   /**
    * Flushes logmessages to log file.
    */
   private void forceFlush()
   {
      lastLogFileFlush = System.currentTimeMillis();
      flushNeeded = false;
      writer.flush();
      try{ currentLogFileDescriptor.sync(); }catch(Exception e){}
   }

   /**
    * Checkes if it is time to change logfile, and if it is - it does.
    * 
    * @exception IOException if there was an error changing logfile.
    */
   public void checkNextLogFileChange() throws IOException
   {
      if(super.checkNextLogChange())
      {
         if( this.maxFileSize.intValue() > 0 )
         {
            // Delete any max size overflow files
            this.deleteExistingLogFiles();
            Thread.yield();
         }
         changeLogFile();
      }
      else if( (this.maxFileSize.intValue() > 0) && (this.bytesWritten > (this.maxFileSize.intValue()*1024*1024)) )
      {
         this.forceFlush(); // Force flush to file to make sure file size is correctly reported
         changeLogFile();
      }
   }
   
   /**
    * Changes the current logfile.
    * 
    * @exception IOException if there was an error while opening a new logfile.
    */
   public void changeLogFile() throws IOException
   {
      this.changeLogFile(false);
   }
   
   /**
    * Changes the current logfile.
    * 
    * @exception IOException if there was an error while opening a new logfile.
    */
   public void changeLogFile(final boolean appendOldLogFile) throws IOException
   {
      // Reset bytesWritten
      this.bytesWritten = 0;
      
      String logName = getCurrentLog();
      
      try
      {
         if(writer != null) writer.close();

         if(appendOldLogFile)
         {
            // Validate any existing log file for append
            this.checkLogFileAppendValidity();
         }
         
         // If max size is set...
         if( this.maxFileSize.intValue() > 0 )
         {
            // ...get first valid max size overflow file name
            logName = this.getMaxSizeOverflowFileName();
         }
         
         String logFileName = logFilePath.stringValue() + logName;
         File file = new File(logFileName);
         boolean exists = file.exists();
         
         if( exists && appendOldLogFile ) this.bytesWritten = file.length();
                  
         FileOutputStream fo = new FileOutputStream(logFileName, appendOldLogFile);
         writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(fo)));
         currentLogFileDescriptor = fo.getFD(); 
               
         if( !exists || (exists && !appendOldLogFile) )
         {
            this.writeFileHeader();
         }
      }
      catch(IOException e)
      {
         logName = getCurrentLog() + ".e" + System.currentTimeMillis();
         String errorName = logFilePath.stringValue() + logName;
         boolean exists = (new File(errorName)).exists();
            
         logWarning("Error creating logFileName (" + e + "). Creating " + errorName + " instead.");
            
         writer = new PrintWriter(new BufferedWriter(new FileWriter(errorName, appendOldLogFile)));
            
         if( !exists )
         {
            this.writeFileHeader();
         }
      }
      
      currentLog.setValue(logName);
   }
   

      
   /**
    * Writes the file header of new log files.
    * 
    * @since 2.1.1 (20051229)
    */
   public void writeFileHeader()
   {
      if( this.fileHeader != null ) this.writer.println(this.fileHeader);
   }
      
   /**
    * Method for building a filtered list of filenames.
    * 
    * @param dir the directory in which the file was found.
    * @param name the name of the file.
    * 
    * @return true if and only if the name should be included in the file list; false otherwise.
    */
   public boolean accept(File dir, String name)
   {
      String prefix = getLogPrefix();
      String suffix = getLogSuffix();
      
      return (name.startsWith(prefix) && name.endsWith(suffix));
   }
   
   /**
    * Returns the names of all logfiles used by this FileAppenderComponent.
    * 
    * @return String array containing filenames.
    */
   public LogData[] getLogs()
   {
      ArrayList logs = new ArrayList();
      
      try
      {
         File logDir = new File(logFilePath.stringValue());
         
         if(!logDir.isDirectory()) logDir = logDir.getParentFile();
         if(logDir == null) logDir = new File(".");

         String[] files = logDir.list(this);
      
         for(int i=0; i<files.length; i++)
         {
            logs.add(new LogData(super.getName(), files[i], new File(logDir.getAbsolutePath(), files[i]).length()));
         }
      }
      catch(Exception e)
      {
         logError("Error getting available logs!", e);
      }
      return (LogData[])logs.toArray(new LogData[0]);
   }
   
   /**
    * Gets an input stream for a specific log.
    */
   public InputStream getLogAsStream(final String log)
   {
      try
      {
         return new BufferedInputStream(new FileInputStream(logFilePath.stringValue() + log));
      }
      catch(IOException ioe)
      {
         logError("Unable to open input stream for log '" + log + "'!", ioe);
         return null;
      }
   }

   
   /* ### PRIVATE UTILITY METHODS  ### */
   
   
   /**
    * Checks if an existing log file may be appended or if not - removes it (them).
    */
   private void checkLogFileAppendValidity()
   {
      if( super.isCyclicPeriodicity() )
      {
         File logFile = new File(logFilePath.stringValue() + getCurrentLog());
         if( logFile.exists() )
         {
            // Check if log file is too old, i.e. if it should be removed rather than appended
            if( (System.currentTimeMillis() - logFile.lastModified()) >= super.getPeriodicityTimeSpan() )
            {
               this.deleteExistingLogFiles();
               Thread.yield();
            }
         }
      }
   }
   
   /**
    * Deletes existing log files for the current log date.
    */
   private void deleteExistingLogFiles()
   {
      String prefix = super.getLogPrefix() + this.calculateLogDateFormatted(super.lastLogChange.dateValue());
      String suffix = super.getLogSuffix();
         
      File[] files = new File(logFilePath.stringValue()).listFiles();
      if( files != null )
      {
         for(int i=0; i<files.length; i++)
         {
            if( files[i].getName().startsWith(prefix) && files[i].getName().endsWith(suffix) )
            {
               if( super.isDebugMode() ) logDebug("Deleting old log file " + files[i] + ".");
               files[i].delete();
            }
         }
      }
   }
   
   /**
    * Gets the first valid max size overflow file name.
    */
   private String getMaxSizeOverflowFileName()
   {
      String prefix = super.getLogPrefix() + this.calculateLogDateFormatted(super.lastLogChange.dateValue());
      String suffix = super.getLogSuffix();
      
      String logName = null;
      File file;
      for(int i=0; i<10000; i++) // Use 10000 as sanity limit
      {
         if( i == 0 ) logName = prefix + suffix;
         else logName = prefix + "_" + i + suffix;
         
         file = new File(logFilePath.stringValue() + logName);
         if( !file.exists() || (file.length() < (this.maxFileSize.intValue()*1024*1024) ) )
         {
            if( super.isDebugMode() ) logDebug("Next max size overflow file name: " + logName + ".");
            break;
         }
      }
      return logName; // Note that if sanity limit is exceeded, the last overflow file name will be used (9999)
   }
   
   /**
    * Replaces invalid filename chars.
    */
   private static String replaceInvalidFileNameChars(final String fileName)
   {
      // Replace illegal characters with _
      final char[] chars = fileName.toCharArray();
      boolean dirty = false;
      
      for(int i=0; i<chars.length; i++)
      {
         if( (chars[i] == ':') || (chars[i] == '\\') || (chars[i] == '/') || (chars[i] == '?') || (chars[i] == '*') ||
              (chars[i] == '\"') || (chars[i] == '|') || (chars[i] == '<') || (chars[i] == '>') )
         {
            chars[i] = '_';
            dirty = true;
         }
      }
      
      if(dirty) return new String(chars);
      else return fileName;
   }
}
